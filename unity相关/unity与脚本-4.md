---
title: unity与脚本-4
date: 2020-02-29 09:23:07
categories:
 - Unity
 - C#编程语言
tags:
 - Unity 2d
 - C#
 - Unity工具
---
**Properties**
编码时经常会有在外部访问类内部变量的需求，可以把这个变量设置为公共的，然后直接访问他。
其实还有更好的方法，就是利用属性，属性本身类似变量，在内部封装了一些变量，被封装的变量称为域，而封装可以更好的控制域被访问的过程。
创建属性：
先确定访问控制符，然后是类型，通常把属性命名为跟域相同，但是首字母大写，在属性名后面是大括号。
像函数一样，在括号内是属性的访问器。
一个属性有get和set两种访问器，分别在取值和赋值时调用。
在get里返回被封装的域，在set访问器里使用value关键字对域赋值。

用属性可以达成两件变量无法做到的事。
首先，不实现get或set的一个，就可以做出一个只读或只写的域。
如果域是私有的，那么没有get和set访问器，就无法读取或写入它。
第二点是访问器就像函数一样，意味着你可以在里面调用其它的函数。

属性的另外一个特点是他们可以自动生成，自动生成属性使用简写写法。在get和set访问器直接打上分号。

**三目运算符**
和C++差不多。

**Static**
静态成员，如某些变量和方法，会在类的所有实例中共享。静态成员可以通过类直接访问。
不需要先实例化一个对象出来，通常成员变量是每个对象唯一的。
静态变量的值是所有实例共享。

需要注意的是，在静态方法中不能使用静态变量，静态方法属于类本身，而非静态变量属于类的实例。

**OverLoading**
重载指给单个函数多个定义的过程，也就是说同样的函数名可以做不同的事。
系统确定正确重载函数版本过程分3步。
如果有完全匹配参数的版本，就运行它。
如果没有完全匹配的，系统就会寻找可能的匹配，并且选择需要最少类型转换的。
最后，如果没有可能的匹配，或有多个版本需要转换类型的数目相同，系统抛出错误。

**Generics**
泛型特性使类和函数等，可以接受类型作为参数。
这就允许你编写通用的程序，而不需要知道将要处理的数据的具体类型。
GetComponent函数使用泛型参数来获取某个类型的组件，getcomponent就是所谓的泛型函数。
	public T GenericMethod<T>(T param)
	{
		return param;
	}
一个简单的泛型函数，首先注意泛型参数<T>,T是它的名称。这里T可以是任何类型的，它的名字也可以是任意的，一般用T。
如果你需要多个泛型参数，可以使用逗号在后面追加，一般T后面用U和V。
函数绑定的类型是T，但是T只是一个占位符。
T只会在函数调用时被替换成实际类型。
不管T最终类型是什么，返回值和参数类型也都是这个值。

如何进行更多的操作？为了知道类型的某些特性，必须限制类型的范围，可以在泛型参数后加入约束。
为函数增加约束时，在参数列表和函数体之间，输入where, 后面跟着需要限制的泛型类型，再接着冒号，在冒号后面是具体的约束，以逗号分隔。
约束分四类，使用class关键字确保T是引用类型，使用struct确保T是值类型，使用new()确保这个类型有公共的，不需要参数的构造函数，可以使用具体的类名，确保T是这个类型，或利用多态性，任何继承此类的类型也可以。最后一种约束时接口类型，可以使用接口名，确保T实现了这个接口。
使用泛型函数时，必须确定你要用的类型。
给类设置泛型类型，会影响类中的属性，域和函数。
创建泛型类也是泛型的常用点，可以方便的创建数据结构。

**继承Inhertiance**
继承是面向对象编程(OOP)，里的核心概念。一个类继承另外一个类时，就可以获取被继承类的一些特性。
在讨论继承时，被继承的类被称为父类或基类，继承的类叫作子类或派生类，继承的结果是，存在于父类的东西，子类也可以访问。
于是子类可以使用这些函数和变量，就像它本身就是父类一样。

在处理继承时，有3个控制符需要了解一下：public，private，protected。

protected属于public和private的混合体。父类里的所有protected特性，在子类都可以访问，像public特性一样，但是不能在除父类和子类之外访问，像private一样。

比如继承了MonoBehavior才能使用update(), start()之类的方法。

继承的概念在游戏开发中非常有用

构造函数是继承中的特例，它还是每个类唯一的，不会共享，当子类的构造函数被调用时，父类的构造函数会自动在子类构造函数之前调用，因为一个类可能有多个构造函数。我们需要具体调用哪个构造函数，可以通过base关键字实现，在子类构造函数参数列表后加冒号，你可以显示调用特定的基类构造函数。如果不显式调用基类构造函数，会隐式调用默认的父类构造函数。
除了调用基类构造函数，base关键字还能访问其它基类的成员，当你需要访问父类的某个特性，而子类这个特性和父类不同时，会用到这一点。

**多态Polymorphism**
多态是继承的一种特性，它允许类有多种类型。

**覆盖Overriding**
覆盖是指在子类中改变基类方法的行为，结果是当我们调用这个方法时，会选择方法的最新或者最接近的覆盖版本。
在继承层次里，通常需要使用与基类不同的方法，在子类里重新创建这个方法，然后实现需要方法做的事情即可。

任何定义为子类的函数，都可以在任意子类中被覆盖。

如果想要子类对函数增加新的功能，但保留基类提供的原有功能。
在实现的时候，就需要在函数中使用base关键字，调用基类版本的函数。
覆盖在多态是非常有用的，通过对基类函数设置virtual，对子类函数设置override，就覆盖了基类版本的函数。
这导致当我们向上转型一个子类引用为基类对象，并调用一个函数，那么函数的子类会被调用。

